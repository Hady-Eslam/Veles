<?php
/**
 * Юнит-тест для класса Timer
 * @file    TimerTest.php
 *
 * PHP version 5.3.9+
 *
 * @author  Alexander Yancharuk <alex@itvault.info>
 * @date    Срд Фев 06 22:00:10 2013
 * @copyright The BSD 3-Clause License.
 */

namespace Veles\Tests\Tools;

use PHPUnit_Framework_TestCase;
use ReflectionObject;
use Veles\Tools\Timer;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-02-06 at 21:58:55.
 */
class TimerTest extends PHPUnit_Framework_TestCase
{
	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 */
	protected function setUp()
	{
		Timer::reset();
	}

	/**
	 * Tears down the fixture, for example, closes a network connection.
	 * This method is called after a test is executed.
	 */
	protected function tearDown()
	{
		Timer::reset();
	}

	/**
	 * @covers Veles\Tools\Timer::start
	 */
	public function testConstants()
	{
		$msg = 'Wrong value of Timer::SECONDS: ' . Timer::SECONDS;
		$this->assertSame(0, Timer::SECONDS, $msg);

		$msg = 'Wrong value of Timer::MILLISECONDS: ' . Timer::MILLISECONDS;
		$this->assertSame(3, Timer::MILLISECONDS, $msg);

		$msg = 'Wrong value of Timer::MICROSECONDS: ' . Timer::MICROSECONDS;
		$this->assertSame(6, Timer::MICROSECONDS, $msg);

		$msg = 'Wrong value of Timer::NANOSECONDS: ' . Timer::NANOSECONDS;
		$this->assertSame(9, Timer::NANOSECONDS, $msg);

		$msg = 'Wrong value of Timer::PICOSECONDS: ' . Timer::PICOSECONDS;
		$this->assertSame(12, Timer::PICOSECONDS, $msg);
	}

	/**
	 * @covers Veles\Tools\Timer::start
	 */
	public function testStart()
	{
		Timer::start();
		$expected = round(microtime(true), 1);

		$object = new ReflectionObject(new Timer);
		$prop = $object->getProperty('start_time');

		$msg = 'Property Timer::$start_time not private';
		$this->assertTrue($prop->isPrivate(), $msg);

		$prop->setAccessible(true);
		$result = round($prop->getValue(), 1);

		$msg = 'Wrong Timer Timer::$start_time type';
		$this->assertInternalType('float', $result, $msg);

		$msg = 'Wrong result of Timer::$start_time property';
		$this->assertSame($expected, $result, $msg);
	}

	/**
	 * @covers Veles\Tools\Timer::reset
	 * @depends testStart
	 */
	public function testReset()
	{
		Timer::start();
		Timer::stop();
		Timer::reset();
		$expected = 0;

		$object = new ReflectionObject(new Timer);

		$start_time = $object->getProperty('start_time');
		$diff = $object->getProperty('diff');

		$start_time->setAccessible(true);
		$result = $start_time->getValue();

		$msg = 'Wrong result of Timer::$start_time property';
		$this->assertSame($expected, $result, $msg);

		$diff->setAccessible(true);
		$result = $start_time->getValue();

		$msg = 'Wrong result of Timer::$diff property';
		$this->assertSame($expected, $result, $msg);
	}

	/**
	 * @covers  Veles\Tools\Timer::stop
	 * @depends testStart
	 * @depends testReset
	 */
	public function testStop()
	{
		Timer::stop();
		$expected = round(microtime(true), 2);

		$object = new ReflectionObject(new Timer);
		$prop = $object->getProperty('diff');

		$msg = 'Property Timer::$diff not private';
		$this->assertTrue($prop->isPrivate(), $msg);

		$prop->setAccessible(true);
		$result = round($prop->getValue(), 2);

		$msg = 'Wrong result of Timer::$diff property';
		$this->assertSame($expected, $result, $msg);
	}

	/**
	 * @covers  Veles\Tools\Timer::get
	 * @depends testStop
	 */
	public function testGet()
	{
		Timer::start();

		$object = new ReflectionObject(new Timer);
		$start_time = $object->getProperty('start_time');
		$start_time->setAccessible(true);
		$start_value = $start_time->getValue();

		Timer::stop();

		$stop_value = microtime(true);

		$result = Timer::get(Timer::MILLISECONDS);
		$expected = round($stop_value - $start_value, 3);


		$msg = 'Wrong Timer result type';
		$this->assertInternalType('float', $result, $msg);

		$msg = 'Wrong Timer result';
		$this->assertSame($expected, $result, $msg);
	}

	/**
	 * @covers  Veles\Tools\Timer::get
	 * @depends testStop
	 * @dataProvider getPrecisionProvider
	 */
	public function testGetPrecision($precision)
	{
		Timer::start();
		Timer::stop();

		$object = new ReflectionObject(new Timer);
		$diff_prop = $object->getProperty('diff');

		$diff_prop->setAccessible(true);
		$diff = $diff_prop->getValue();

		$expected = round($diff, $precision);

		$result = Timer::get($precision);

		$msg = 'Wrong Timer precision result';
		$this->assertSame($expected, $result, $msg);
	}

	/**
	 * Data-provider for testGetPrecision
	 */
	public function getPrecisionProvider()
	{
		return array(
			array(Timer::SECONDS),
			array(Timer::MILLISECONDS),
			array(Timer::MICROSECONDS),
			array(Timer::NANOSECONDS),
			array(Timer::PICOSECONDS)
		);
	}
}
