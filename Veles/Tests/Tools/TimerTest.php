<?php
/**
 * Юнит-тест для класса Timer
 * @file    TimerTest.php
 *
 * PHP version 5.3.9+
 *
 * @author  Yancharuk Alexander <alex@itvault.info>
 * @date    Срд Фев 06 22:00:10 2013
 * @copyright The BSD 3-Clause License.
 */

namespace Veles\Tests\Tools;

use \Veles\Tools\Timer;
use \ReflectionObject;
use \PHPUnit_Framework_TestCase;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-02-06 at 21:58:55.
 */
class TimerTest extends PHPUnit_Framework_TestCase
{
    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        Timer::reset();
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }

    /**
     * @covers Veles\Tools\Timer::start
     */
    public function testStart()
    {
        Timer::start();
        $expected = round(microtime(true), 3);

        $object = new ReflectionObject(new Timer);
        $prop = $object->getProperty('start_time');

        $msg = 'Property Timer::$start_time not private';
        $this->assertTrue($prop->isPrivate(), $msg);

        $prop->setAccessible(true);
        $result = round($prop->getValue(), 3);

        $msg = 'Wrong result of Timer::$start_time property';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::stop
     * @depends testStart
     */
    public function testStop()
    {
        Timer::start();
        Timer::stop();
        $expected = round(microtime(true), 3);

        $object = new ReflectionObject(new Timer);
        $prop = $object->getProperty('stop_time');

        $msg = 'Property Timer::$stop_time not private';
        $this->assertTrue($prop->isPrivate(), $msg);

        $prop->setAccessible(true);
        $result = round($prop->getValue(), 3);

        $msg = 'Wrong result of Timer::$stop_time property';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::get
     * @depends testStart
     * @depends testStop
     */
    public function testGet()
    {
        Timer::start();
        usleep(3000);
        Timer::stop();
        $expected = 0.003;

        $result = Timer::get(Timer::MILLISECONDS);

        $this->assertInternalType('float', $result);

        $msg = 'Wrong Timer result';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::reset
     * @depends testStart
     * @depends testStop
     */
    public function testReset()
    {
        Timer::start();
        Timer::stop();
        Timer::reset();
        $expected = 0;

        $object = new ReflectionObject(new Timer);

        $stop_time  = $object->getProperty('stop_time');
        $start_time = $object->getProperty('start_time');

        $stop_time->setAccessible(true);
        $result = $stop_time->getValue();

        $msg = 'Wrong result of Timer::$stop_time property';
        $this->assertSame($result, $expected, $msg);

        $start_time->setAccessible(true);
        $result = $start_time->getValue();

        $msg = 'Wrong result of Timer::$start_time property';
        $this->assertSame($result, $expected, $msg);
    }
}
