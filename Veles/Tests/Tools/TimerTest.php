<?php
/**
 * Юнит-тест для класса Timer
 * @file    TimerTest.php
 *
 * PHP version 5.3.9+
 *
 * @author  Yancharuk Alexander <alex@itvault.info>
 * @date    Срд Фев 06 22:00:10 2013
 * @copyright The BSD 3-Clause License.
 */

namespace Veles\Tests\Tools;

use \Veles\Tools\Timer;
use \ReflectionObject;
use \PHPUnit_Framework_TestCase;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-02-06 at 21:58:55.
 */
class TimerTest extends PHPUnit_Framework_TestCase
{
    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        Timer::reset();
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
        Timer::reset();
    }

    /**
     * @covers Veles\Tools\Timer::start
     */
    public function testConstants()
    {
        $msg = 'Wrong value of Timer::SECONDS: ' . Timer::SECONDS;
        $this->assertSame(Timer::SECONDS, 0, $msg);

        $msg = 'Wrong value of Timer::MILLISECONDS: ' . Timer::MILLISECONDS;
        $this->assertSame(Timer::MILLISECONDS, 3, $msg);

        $msg = 'Wrong value of Timer::MICROSECONDS: ' . Timer::MICROSECONDS;
        $this->assertSame(Timer::MICROSECONDS, 6, $msg);

        $msg = 'Wrong value of Timer::NANOSECONDS: ' . Timer::NANOSECONDS;
        $this->assertSame(Timer::NANOSECONDS, 9, $msg);

        $msg = 'Wrong value of Timer::PICOSECONDS: ' . Timer::PICOSECONDS;
        $this->assertSame(Timer::PICOSECONDS, 12, $msg);
    }

    /**
     * @covers Veles\Tools\Timer::start
     */
    public function testStart()
    {
        Timer::start();
        $expected = round(microtime(true), 2);

        $object = new ReflectionObject(new Timer);
        $prop = $object->getProperty('start_time');

        $msg = 'Property Timer::$start_time not private';
        $this->assertTrue($prop->isPrivate(), $msg);

        $prop->setAccessible(true);
        $result = round($prop->getValue(), 2);

        $msg = 'Wrong result of Timer::$start_time property';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::stop
     * @depends testStart
     */
    public function testStop()
    {
        Timer::stop();
        $expected = round(microtime(true), 2);

        $object = new ReflectionObject(new Timer);
        $prop = $object->getProperty('stop_time');

        $msg = 'Property Timer::$stop_time not private';
        $this->assertTrue($prop->isPrivate(), $msg);

        $prop->setAccessible(true);
        $result = round($prop->getValue(), 2);

        $msg = 'Wrong result of Timer::$stop_time property';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::get
     * @depends testStop
     */
    public function testGet()
    {
        Timer::start();
        Timer::stop();

        $object = new ReflectionObject(new Timer);
        $start_time = $object->getProperty('start_time');
        $stop_time = $object->getProperty('stop_time');

        $start_time->setAccessible(true);
        $start = $start_time->getValue();
        $stop_time->setAccessible(true);
        $stop = $stop_time->getValue();

        $expected = round($stop - $start, Timer::MICROSECONDS);
        $result = Timer::get();

        $this->assertInternalType('float', $result);

        $msg = 'Wrong Timer result';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * @covers  Veles\Tools\Timer::get
     * @depends testStop
     * @dataProvider getPrecisionProvider
     */
    public function testGetPrecision($precision)
    {
        Timer::start();
        Timer::stop();

        $object = new ReflectionObject(new Timer);
        $start_time = $object->getProperty('start_time');
        $stop_time = $object->getProperty('stop_time');

        $start_time->setAccessible(true);
        $start = $start_time->getValue();
        $stop_time->setAccessible(true);
        $stop = $stop_time->getValue();

        $expected = round($stop - $start, $precision);

        $result = Timer::get($precision);

        $msg = 'Wrong Timer precision result';
        $this->assertSame($result, $expected, $msg);
    }

    /**
     * Data-provider for testGetPrecision
     */
    public function getPrecisionProvider()
    {
        return array(
            array(Timer::SECONDS),
            array(Timer::MILLISECONDS),
            array(Timer::MICROSECONDS),
            array(Timer::NANOSECONDS),
            array(Timer::PICOSECONDS)
        );
    }

    /**
     * @covers  Veles\Tools\Timer::reset
     * @depends testStop
     */
    public function testReset()
    {
        Timer::start();
        Timer::stop();
        Timer::reset();
        $expected = 0;

        $object = new ReflectionObject(new Timer);

        $stop_time  = $object->getProperty('stop_time');
        $start_time = $object->getProperty('start_time');

        $stop_time->setAccessible(true);
        $result = $stop_time->getValue();

        $msg = 'Wrong result of Timer::$stop_time property';
        $this->assertSame($result, $expected, $msg);

        $start_time->setAccessible(true);
        $result = $start_time->getValue();

        $msg = 'Wrong result of Timer::$start_time property';
        $this->assertSame($result, $expected, $msg);
    }
}
